--   SQL UNION 聯集(不包含重覆值)


-- 1.SQL查詢子句之間，欄位個數必須一致
-- 2.SQL查詢子句之間，欄位型態必須一致(MySQL無此限制)
-- 3.SQL查詢子句之間，欄位名稱不須一致
-- NULL,1,2
SELECT GEOGRAPHY_ID FROM store_information
UNION
-- 1,2,3
SELECT GEOGRAPHY_ID FROM geography;

-- FULL JOIN = LEFT JOIN + RIGHT JOIN
SELECT G.GEOGRAPHY_ID, G.REGION_NAME,
	S.STORE_ID, S.STORE_NAME, S.SALES, S.GEOGRAPHY_ID, S.STORE_DATE
FROM geography G LEFT JOIN STORE_INFORMATION S
ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
UNION
SELECT G.GEOGRAPHY_ID, G.REGION_NAME,
	S.STORE_ID, S.STORE_NAME, S.SALES, S.GEOGRAPHY_ID, S.STORE_DATE
FROM geography G RIGHT JOIN STORE_INFORMATION S
ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;

-- 3.SQL查詢子句之間，欄位名稱不須一致
SELECT STORE_NAME FROM store_information
UNION
-- 1,2,3
SELECT REGION_NAME FROM geography;

--   SQL UNION ALL 聯集(包含重覆值)
-- NULL,1,2
SELECT GEOGRAPHY_ID FROM store_information
UNION ALL
-- 1,2,3
SELECT GEOGRAPHY_ID FROM geography;


--   SQL INTERSECT 交集
-- MySQL不支援INTERSECT

/*
-- NULL,1,2
SELECT GEOGRAPHY_ID FROM store_information
INTERSECT
-- 1,2,3
SELECT GEOGRAPHY_ID FROM geography;
*/

-- MySQL INTERSECT 替代方案
-- https://www.yiibai.com/mysql/sql-union-mysql.html
-- INNER JOIN + DISTINCT = INTERSECT 查詢交集結果
SELECT DISTINCT S.GEOGRAPHY_ID 
FROM store_information S 
JOIN geography G ON S.GEOGRAPHY_ID = G.GEOGRAPHY_ID;


--   SQL MINUS 排除(不包含重覆值)
-- MySQL不支援
-- MINUS (Oracle)、EXCEPT (MS SQL)
/*
-- 1,2,3
SELECT GEOGRAPHY_ID FROM geography
MINUS
-- NULL,1,2
SELECT GEOGRAPHY_ID FROM store_information;
結果:3
*/

-- https://www.yiibai.com/mysql/minus.html
-- LEFT JOIN + table2.id IS NULL = MINUS
SELECT G.GEOGRAPHY_ID
FROM geography G
LEFT JOIN store_information S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
WHERE S.GEOGRAPHY_ID IS NULL;

--   SQL SubQuery 子查詢

-- 『簡單子查詢』 (Simple Subquery)
-- 營業額最高的商店
-- 外查詢
SELECT * FROM store_information
WHERE SALES = (
	-- 內查詢
	SELECT MAX(SALES) FROM store_information
);

-- 『相關子查詢』(Correlated Subquery)
-- 外查詢
SELECT S.*
FROM store_information S
WHERE S.GEOGRAPHY_ID IN (
	-- 內查詢
	SELECT G.GEOGRAPHY_ID FROM geography G
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
);

SELECT G.*, S.*
FROM (
	SELECT GEOGRAPHY_ID, REGION_NAME FROM geography
) G,
(
	SELECT STORE_ID, SALES, STORE_NAME, STORE_DATE, GEOGRAPHY_ID FROM store_information
)S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;

-- WITH (Common Table Expressions)
WITH G AS (
	SELECT GEOGRAPHY_ID, REGION_NAME FROM geography
),
S AS (
	SELECT STORE_ID, SALES, STORE_NAME, STORE_DATE, GEOGRAPHY_ID FROM store_information
)
SELECT G.*, S.*
FROM G, S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;

-- 『相關子查詢』(Correlated Subquery)
WITH G AS (
	SELECT GEOGRAPHY_ID, REGION_NAME FROM geography
),
S AS (
	SELECT G.GEOGRAPHY_ID, G.REGION_NAME,
		S.STORE_ID, S.SALES, S.STORE_NAME, S.STORE_DATE
    FROM store_information S, G
    WHERE  G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
)
SELECT S.* FROM S;


--   SQL EXISTS 存在式關聯查詢
-- EXISTS 是用來測試「內查詢」有沒有產生任何結果。
-- 如果有的話，系統就會執行「外查詢」中的 SQL。
-- 若是沒有的話，那整個 SQL 語句就不會產生任何結果。

-- 外查詢
-- 13,250
SELECT SUM(SALES) FROM store_information
WHERE EXISTS (
	-- 內查詢
	SELECT GEOGRAPHY_ID,REGION_NAME FROM geography WHERE GEOGRAPHY_ID = 2
);


-- 外查詢
-- 13,250
SELECT SUM(SALES) FROM store_information S
WHERE EXISTS (
	-- 內查詢
	SELECT GEOGRAPHY_ID,REGION_NAME FROM geography G
    WHERE GEOGRAPHY_ID = 2
    AND G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
);

--   SQL CASE WHEN 條件查詢
-- CASE接欄位
SELECT STORE_ID, STORE_NAME, SALES,
	CASE STORE_NAME
		WHEN 'Los Angeles' THEN SALES * 2
        WHEN 'San Diego' THEN SALES * 1.5
	ELSE SALES END "NEW_SALES"
FROM store_information;

-- CASE 不接欄位，只有WHEN條件
SELECT STORE_ID, STORE_NAME, SALES,
	CASE 
		WHEN (SALES BETWEEN 0 AND 1000) THEN '0-1000'
        WHEN (SALES BETWEEN 1001 AND 2000) THEN '1001-2000'
        WHEN (SALES BETWEEN 2001 AND 3000) THEN '2001-3000'
        WHEN SALES > 3000 THEN '>3000'
	END "SALES_RANGE"
FROM store_information;


SELECT STORE_ID, STORE_NAME, SALES,
	RANK()OVER(ORDER BY SALES DESC) "RANK",
    DENSE_RANK()OVER(ORDER BY SALES DESC) "DENSE_RANK",
    ROW_NUMBER()OVER(ORDER BY SALES DESC) "ROW_NUMBER"
FROM store_information;


SELECT STORE_ID, STORE_NAME, SALES,GEOGRAPHY_ID,
	RANK()OVER(
	  PARTITION BY GEOGRAPHY_ID	ORDER BY SALES DESC
	) "GEOGRAPHY_RANK"
FROM store_information;

-- Aggregate Functions with OVER Clause (聚合函數)
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
    -- 依「區域劃分」取營業額"最小值"
    MIN(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MIN_SALES,
    -- 依「區域劃分」取營業額"最大值"
    MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MAX_SALES,
    -- 依「區域劃分」取商店"數量"
    COUNT(STORE_ID) OVER (PARTITION BY GEOGRAPHY_ID) COUNT_STORE_ID,
    -- 依「區域劃分」取營業額"總和"
    SUM(SALES) OVER (PARTITION BY GEOGRAPHY_ID) SUM_SALES,
    -- 依「區域劃分」取營業額"平均"
    AVG(SALES) OVER (PARTITION BY GEOGRAPHY_ID) AVG_SALES
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES;

