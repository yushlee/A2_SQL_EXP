-- SQL UNION 聯集(不包含重覆值)
-- 1.多個SQL語句的結果合併起來
-- 2.UNION與JOIN差別在於，JOIN...ON必須指定欄位關聯(連接)
-- 3.所有SQL子句的查詢"欄位個數"必須一致、"欄位型態"必須一致 MySQL無此限制
SELECT STORE_ID,STORE_NAME FROM store_information
UNION
SELECT GEOGRAPHY_ID,REGION_NAME FROM geography
UNION
SELECT EMPLOYEE_ID, FIRST_NAME FROM employees;

-- MySQL FULL JOIN = LEFT JOIN UNION RIGHT JOIN
SELECT S.STORE_ID, S.STORE_NAME, S.SALES, S.GEOGRAPHY_ID, G.REGION_NAME
FROM store_information S LEFT JOIN geography G
ON S.GEOGRAPHY_ID = G.GEOGRAPHY_ID
UNION
SELECT S.STORE_ID, S.STORE_NAME, S.SALES, S.GEOGRAPHY_ID, G.REGION_NAME
FROM store_information S RIGHT JOIN geography G
ON S.GEOGRAPHY_ID = G.GEOGRAPHY_ID;

-- SQL UNION ALL 聯集(包含重覆值)
SELECT STORE_NAME FROM store_information
UNION ALL
SELECT REGION_NAME FROM geography;


-- SQL INTERSECT 交集
-- MySQL沒有支援INTERSECT
/*
SELECT GEOGRAPHY_ID FROM store_information
INTERSECT
SELECT GEOGRAPHY_ID FROM geography;
*/

-- https://www.yiibai.com/mysql/sql-union-mysql.html
-- INNER JOIN + DISTINCT = INTERSECT 查詢交集結果
SELECT DISTINCT S.GEOGRAPHY_ID 
FROM store_information S
JOIN geography G ON S.GEOGRAPHY_ID = G.GEOGRAPHY_ID;

-- SQL MINUS 排除(不包含重覆值) 
-- MySQL沒有支援 MINUS
/*
-- 1,2,3
-- 1,2,null
-- MINUS = 3
SELECT GEOGRAPHY_ID FROM geography
MINUS
SELECT GEOGRAPHY_ID FROM store_information;
*/

-- https://www.yiibai.com/mysql/minus.html
-- LEFT JOIN + table2.id IS NULL = MINUS
SELECT G.GEOGRAPHY_ID
FROM geography G
LEFT JOIN store_information S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
WHERE  S.GEOGRAPHY_ID IS NULL;

-- SQL SubQuery 子查詢
-- 查詢"最高營業額"的"商店資料"
-- 外查詢
SELECT STORE_ID, STORE_NAME, SALES 
FROM store_information
WHERE SALES = (
	-- 內查詢
	SELECT MAX(SALES) FROM store_information
);

-- 簡單子查詢
-- 外查詢
-- SELECT SUM(SALES)
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID 
FROM store_information
WHERE GEOGRAPHY_ID IN (
	-- 內查詢
	SELECT GEOGRAPHY_ID FROM geography 
    WHERE REGION_NAME = 'West' OR REGION_NAME = 'East'
);

-- 相關子查詢
-- 外查詢
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID 
FROM store_information S
WHERE GEOGRAPHY_ID IN (
	-- 內查詢
	SELECT GEOGRAPHY_ID FROM geography G
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
);

SELECT G.*, S.*
FROM (
	SELECT GEOGRAPHY_ID,REGION_NAME FROM geography
) G,
(
	SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID FROM store_information
) S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;

-- 查詢與查詢之間彼此獨立不能互相使用對方的欄位
SELECT G.*, S.*
FROM (
	SELECT GEOGRAPHY_ID,REGION_NAME FROM geography
) G JOIN
(
	SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID FROM store_information
) S
ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;

-- WITH (Common Table Expressions)
WITH G AS (
	SELECT GEOGRAPHY_ID,REGION_NAME FROM geography
),
S AS (
	SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID FROM store_information
)
SELECT G.*, S.*
FROM G JOIN S
ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


WITH G AS (
	SELECT GEOGRAPHY_ID,REGION_NAME FROM geography
),
STORE AS (
	SELECT G.*, S.STORE_ID, S.STORE_NAME, S.SALES
    FROM store_information S, G
    WHERE S.GEOGRAPHY_ID= G.GEOGRAPHY_ID
)
SELECT * FROM STORE;

-- SQL EXISTS 存在式關聯查詢
SELECT SUM(SALES) 
FROM store_information
WHERE EXISTS (
	-- 測試「內查詢」有沒有產生任何結果
	SELECT * FROM geography WHERE GEOGRAPHY_ID = 2
);


SELECT SUM(SALES) 
FROM store_information S
WHERE EXISTS (
	-- 測試「內查詢」有沒有產生任何結果
	SELECT * FROM geography G 
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
);


-- SQL CASE WHEN 條件查詢
-- 1.CASE後面接欄位
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	CASE GEOGRAPHY_ID
		WHEN 1 THEN '東區'
        WHEN 2 THEN '西區'
        WHEN 3 THEN '北區'
	ELSE '不分區' END 'GEOGRAPHY_NAME'
FROM store_information;

-- 2.CASE後面接條件
-- 0 ~ 1000
-- 1001 ~ 2000
-- 2001 ~ 3000
-- > 3000
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	CASE
		WHEN (SALES BETWEEN 0 AND 1000) THEN '0 ~ 1000'
        WHEN (SALES BETWEEN 1001 AND 2000) THEN '1001 ~ 2000'
        WHEN (SALES BETWEEN 2001 AND 3000) THEN '2001 ~ 3000'
        WHEN (SALES > 3000) THEN '>3000'
	END 'SALES_RANGE'
FROM store_information;


SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	RANK()OVER(ORDER BY SALES DESC) 'STORE_RANK'
FROM store_information;


SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	RANK() OVER ( PARTITION BY GEOGRAPHY_ID ORDER BY SALES DESC) 'GEOGRAPHY_STORE_RANK'
FROM store_information;


SELECT STORE_ID, STORE_NAME, SALES, STORE_DATE, GEOGRAPHY_ID,
	ROW_NUMBER () OVER (ORDER BY SALES DESC, STORE_DATE DESC) 'ROW_NUMBER_STORE',
	RANK() OVER (ORDER BY SALES DESC) 'STORE_RANK',
    DENSE_RANK() OVER (ORDER BY SALES DESC) 'DENSE_STORE_RANK',
    PERCENT_RANK() OVER (ORDER BY SALES DESC) 'PERCENT_STORE_RANK'    
FROM store_information;

-- Aggregate Functions with OVER Clause (聚合函數)
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
    -- 依「區域劃分」取營業額"最小值"
    MIN(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MIN_SALES,
    -- 依「區域劃分」取營業額"最大值"
    MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MAX_SALES,
    -- 依「區域劃分」取商店"數量"
    COUNT(STORE_ID) OVER (PARTITION BY GEOGRAPHY_ID) COUNT_STORE_ID,
    -- 依「區域劃分」取營業額"總和"
    SUM(SALES) OVER (PARTITION BY GEOGRAPHY_ID) SUM_SALES,
    -- 依「區域劃分」取營業額"平均"
    AVG(SALES) OVER (PARTITION BY GEOGRAPHY_ID) AVG_SALES
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES;

-- Analytic Functions with OVER Clause (分析函數)
SELECT STORE_ID, STORE_NAME,
    ROW_NUMBER( ) OVER (ORDER BY SALES) ROWNO_STORE,
    SALES,
    -- 依「營業額」排序取"上一個"營業額
    LAG(SALES) OVER (ORDER BY SALES) PREV_SALES,
    -- 依「營業額」排序取"下一個"營業額
    LEAD(SALES) OVER (ORDER BY SALES) NEXT_SALES
FROM STORE_INFORMATION
ORDER BY SALES;



